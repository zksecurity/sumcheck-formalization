/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1755dfb9-c095-473f-b397-f4f627d99d62

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Probability of a predicate holding for a uniformly random element of a finite set.
-/
open Finset

/-- Probability of a predicate holding for a uniformly random element of a finite set. -/
noncomputable def Prob {α : Type*} (S : Finset α) (p : α → Prop) [DecidablePred p] : ℚ :=
  (S.filter p).card / S.card

/-
Let $g \in \FF[X_1, \ldots, X_n]$ be a non-zero polynomial of total degree at most $d$, and let $S \subseteq \FF$ be a finite non-empty subset. Then
\[
  \Prob_{\mathbf{r} \sim S^n}\bigl[g(\mathbf{r}) = 0\bigr]
  \;\leq\; \frac{d}{|S|}\,,
\]
where $\mathbf{r} = (r_1, \ldots, r_n)$ is drawn uniformly at random from $S^n$.
-/
open MvPolynomial Finset

/-- The Schwartz-Zippel Lemma. -/
theorem schwartz_zippel {F : Type*} [Field F] [Fintype F] [DecidableEq F]
    {n : ℕ} (g : MvPolynomial (Fin n) F) (S : Finset F) (hS : S.Nonempty)
    (hg : g ≠ 0) {d : ℕ} (hd : g.totalDegree ≤ d) :
    Prob (Fintype.piFinset fun _ => S) (fun x => eval x g = 0) ≤ d / S.card := by
  refine' le_trans _ ( div_le_div_of_nonneg_right ( Nat.cast_le.mpr hd ) <| Nat.cast_nonneg _ );
  convert MvPolynomial.schwartz_zippel_totalDegree _ _;
  any_goals exact g;
  any_goals exact S;
  all_goals try infer_instance;
  · rw [ ← NNRat.coe_le_coe ] ; norm_num [ Prob ];
  · exact hg

/-
Corollary (Univariate root bound): Let $p \in \FF[X]$ be a non-zero univariate polynomial of degree
at most $d$. Then for $r$ drawn uniformly at random from $\FF$:
$\Prob_{r \sim \FF}[p(r) = 0] \leq d / |\FF|$.
This is the Schwartz-Zippel lemma with $n = 1$ and $S = \FF$.
-/
open Polynomial Finset

theorem univariate_root_bound {F : Type*} [Field F] [Fintype F] [DecidableEq F]
    (p : Polynomial F) (hp : p ≠ 0) {d : ℕ} (hd : p.degree ≤ d) :
    Prob (Finset.univ : Finset F) (fun r => p.eval r = 0) ≤ (d : ℚ) / Fintype.card F := by
  sorry

/-
Probability over a product set can be computed by summing the probabilities of the conditioned events.
-/
open Finset

theorem prob_split {α : Type*} [Fintype α] [DecidableEq α] {n : ℕ}
    (S : Finset α) (p : (Fin (n + 1) → α) → Prop) [DecidablePred p] :
    Prob (Fintype.piFinset fun _ : Fin (n + 1) => S) p =
    (∑ x ∈ S, Prob (Fintype.piFinset fun _ : Fin n => S) (fun r => p (Fin.cons x r))) / S.card := by
      unfold Prob;
      simp +decide only [div_eq_mul_inv, Finset.sum_mul _ _ _];
      rw [ ← Finset.sum_mul _ _ _, ← Finset.sum_mul _ _ _ ];
      rw [ show ( Fintype.piFinset fun _ : Fin ( n + 1 ) => S ) = Finset.image ( fun x : α × ( Fin n → α ) => Fin.cons x.1 x.2 ) ( S ×ˢ Fintype.piFinset fun _ : Fin n => S ) from ?_, Finset.card_image_of_injective ];
      · rw [ Finset.card_filter ];
        rw [ Finset.sum_image ];
        · rw [ Finset.sum_product ] ; simp +decide [ Finset.sum_ite ] ; ring;
        · intro x hx y hy; aesop;
      · intro x y hxy;
        simp_all +decide [ funext_iff, Fin.forall_fin_succ ];
        exact Prod.ext hxy.1 ( funext hxy.2 );
      · ext; simp [Fin.cons];
        exact ⟨ fun h => ⟨ _, _, ⟨ h 0, fun i => h ( Fin.succ i ) ⟩, by ext i; cases i using Fin.inductionOn <;> rfl ⟩, by rintro ⟨ a, b, ⟨ ha, hb ⟩, rfl ⟩ i; cases i using Fin.inductionOn <;> aesop ⟩

/-
Let $g \in \FF[X_1, \ldots, X_n]$ and let $H \subseteq \FF$ be a finite non-empty subset. The multivariate sum of $g$ over $H$ is
\[
  \sigma(g, H, n)
  \;=\; \sum_{(x_1, \ldots, x_n) \in H^n} g(x_1, \ldots, x_n).
\]
-/
open MvPolynomial Finset

/-- The multivariate sum of g over H^n. -/
noncomputable def sigma {F : Type*} [Field F] [Fintype F] {n : ℕ}
    (g : MvPolynomial (Fin n) F) (H : Finset F) : F :=
  ∑ x ∈ Fintype.piFinset (fun _ => H), eval x g

/-
The honest prover sends, in round $i$ (given previous challenges $r_1, \ldots, r_{i-1}$), the polynomial
\[
  s_i^*(X)
  \;=\; \sum_{(x_{i+1}, \ldots, x_n) \in H^{n-i}}
    g(r_1, \ldots, r_{i-1},\, X,\, x_{i+1}, \ldots, x_n).
\]
-/
open MvPolynomial Finset Polynomial

/-- The honest prover's polynomial for round i (0-indexed, corresponding to variable X_i).
    r contains the challenges for variables X_0, ..., X_{i-1}. -/
noncomputable def honest_prover_poly {F : Type*} [Field F] [Fintype F] {n : ℕ}
    (g : MvPolynomial (Fin n) F) (H : Finset F) (i : Fin n) (r : Fin i → F) : Polynomial F :=
  ∑ x ∈ Fintype.piFinset (fun _ : Fin (n - 1 - i) => H),
    aeval (fun k : Fin n =>
      if h : k < i then Polynomial.C (r ⟨k, h⟩)
      else if h' : k = i then Polynomial.X
      else Polynomial.C (x ⟨k - (i + 1), by
        grind⟩)) g

/-
If $g$ has individual degree at most $d$ in variable $X_i$, then the honest prover's polynomial for round $i$ has degree at most $d$.
-/
open MvPolynomial Finset Polynomial

theorem honest_prover_degree_le {F : Type*} [Field F] [Fintype F] {n : ℕ}
    (g : MvPolynomial (Fin n) F) (H : Finset F) (i : Fin n) (r : Fin i → F)
    {d : ℕ} (hg : degreeOf i g ≤ d) :
    (honest_prover_poly g H i r).degree ≤ d := by
  refine' le_trans ( Polynomial.degree_sum_le _ _ ) _;
  -- Since $g$ has individual degree at most $d$ in $X_i$, the degree of each term in the sum is at most $d$.
  have h_deg_term : ∀ x : Fin (n - 1 - i) → F, (MvPolynomial.aeval (fun k : Fin n => if h : k < i then Polynomial.C (r ⟨k, h⟩) else if h' : k = i then Polynomial.X else Polynomial.C (x ⟨k - (i + 1), by
    omega⟩)) g).degree ≤ d := by
    intro x
    have h_deg_term : ∀ m ∈ g.support, (m i : ℕ) ≤ d := by
      simp_all +decide [ MvPolynomial.degreeOf_eq_sup ];
    rw [ MvPolynomial.aeval_def, MvPolynomial.eval₂_eq' ];
    refine' le_trans ( Polynomial.degree_sum_le _ _ ) ( Finset.sup_le _ );
    intro m hm; simp +decide [ Polynomial.degree_prod, Polynomial.degree_X_pow, Polynomial.degree_C, h_deg_term m hm ] ;
    refine' le_trans ( add_le_add ( Polynomial.degree_C_le ) ( Finset.sum_le_sum fun j _ => _ ) ) _;
    use fun j => if j = i then m i else 0;
    · split_ifs <;> simp +decide [ *, Polynomial.degree_le_iff_coeff_zero ];
      · exact absurd ‹_› ( ne_of_lt ‹_› );
      · exact mul_nonpos_of_nonneg_of_nonpos ( Nat.cast_nonneg _ ) ( Polynomial.degree_C_le );
      · exact mul_nonpos_of_nonneg_of_nonpos ( Nat.cast_nonneg _ ) ( Polynomial.degree_C_le );
    · aesop;
  exact Finset.sup_le fun x hx => h_deg_term x

/-
If $i=0$, then $\sum_{a \in H} s_i^*(a) = \sigma(g, H, n)$.
-/
open MvPolynomial Finset Polynomial

theorem honest_prover_sum_check_zero {F : Type*} [Field F] [Fintype F] {n : ℕ}
    (g : MvPolynomial (Fin n) F) (H : Finset F) (i : Fin n) (r : Fin i → F)
    (h_zero : i.val = 0) :
    ∑ a ∈ H, (honest_prover_poly g H i r).eval a = sigma g H := by
  revert h_zero;
  unfold honest_prover_poly sigma;
  rcases n with ( _ | n ) <;> simp_all +decide [ Finset.sum_ite ];
  · exact Fin.elim0 i;
  · rintro rfl; simp +decide [ Polynomial.eval_finset_sum, MvPolynomial.aeval_def ] ;
    rw [ Finset.sum_sigma' ];
    refine' Finset.sum_bij ( fun x _ => Fin.cons x.1 x.2 ) _ _ _ _ <;> simp +decide;
    · exact fun a ha₁ ha₂ i => by cases i using Fin.inductionOn <;> simp +decide [ * ] ;
    · aesop;
    · exact fun b hb => ⟨ b 0, fun i => b i.succ, ⟨ hb 0, fun i => hb _ ⟩, by ext i; cases i using Fin.inductionOn <;> rfl ⟩;
    · simp +decide [ MvPolynomial.eval_eq', MvPolynomial.eval₂_eq' ];
      simp +decide [ Polynomial.eval_finset_sum, Polynomial.eval_mul, Polynomial.eval_prod, Polynomial.eval_pow, Polynomial.eval_X, Polynomial.eval_C ];
      simp +decide [ Fin.prod_univ_succ, Fin.cons ]

/-
For any $j < n-1$, the sum of the honest prover's polynomial for round $j+1$ over $H$ equals the evaluation of the honest prover's polynomial for round $j$ at the challenge $r_j$.
-/
open MvPolynomial Finset Polynomial

theorem honest_prover_sum_check_succ {F : Type*} [Field F] [Fintype F] {m : ℕ}
    (g : MvPolynomial (Fin (m + 1)) F) (H : Finset F) (j : Fin m) (r : Fin (j.val + 1) → F) :
    ∑ a ∈ H, (honest_prover_poly g H (Fin.succ j) r).eval a =
    (honest_prover_poly g H (Fin.castSucc j) (fun k : Fin j.val => r (k.castSucc))).eval (r (Fin.last j.val)) := by
  unfold honest_prover_poly
  simp only [Polynomial.eval_finset_sum, MvPolynomial.aeval_def]
  convert Finset.sum_comm using 1;
  rw [ ← Finset.sum_product' ];
  refine' Finset.sum_bij ( fun x _ => ( fun k => x ⟨ k + 1, by
    exact Nat.lt_pred_iff.mp k.2 ⟩, x ⟨ 0, by
    exact Nat.sub_pos_of_lt j.2 ⟩ ) ) _ _ _ _ <;> simp +decide;
  · exact fun a ha => ⟨ fun i => ha _, ha _ ⟩;
  · intro a₁ ha₁ a₂ ha₂ h₁ h₂; ext ⟨ k, hk ⟩ ; induction' k with k ih <;> simp_all +decide [ funext_iff ] ;
    convert h₁ ⟨ k, by omega ⟩;
  · intro a b ha hb
    use fun k => if hk : k.val < 1 then b else a ⟨k.val - 1, by
      omega⟩;
    aesop;
  · intro a ha;
    all_goals generalize_proofs at *;
    rw [ MvPolynomial.eval₂_eq', MvPolynomial.eval₂_eq' ];
    simp +decide [ Polynomial.eval_finset_sum, Polynomial.eval_mul, Polynomial.eval_prod, Polynomial.eval_pow, Polynomial.eval_X, Polynomial.eval_C ];
    refine' Finset.sum_congr rfl fun x hx => _;
    refine' congr_arg _ ( Finset.prod_congr rfl fun i hi => _ );
    split_ifs <;> simp_all +decide [Fin.ext_iff, Nat.lt_succ_iff] <;> (
      have : (j.castSucc : ℕ) = j := Fin.coe_castSucc j
      have : (j.succ : ℕ) = (j : ℕ) + 1 := Fin.val_succ j
      have : (j : ℕ) < m := j.isLt
      simp only [Fin.lt_def, Fin.le_def] at *
      first | omega | (convert rfl using 4 <;> omega))

/-
A prover strategy is a collection of functions $P_i$ that map previous challenges to a polynomial. The verifier accepts if all degree checks pass, the first sum check matches $C$, subsequent sum checks match the previous evaluation, and the final evaluation matches $g$.
-/
open MvPolynomial Finset Polynomial

/-- A prover strategy is a collection of functions P_i that map previous challenges to a polynomial. -/
def ProverStrategy (n : ℕ) (F : Type*) [Field F] :=
  ∀ i : Fin n, (Fin i → F) → Polynomial F

/-- The verifier accepts if all checks pass. -/
def VerifierAccepts {F : Type*} [Field F] [Fintype F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin n) F) (H : Finset F) (C : F) (d : ℕ)
    (P : ProverStrategy n F) (r : Fin n → F) : Prop :=
  (∀ i : Fin n, (P i (fun k : Fin i => r ⟨k.val, lt_trans k.is_lt i.is_lt⟩)).degree ≤ d) ∧
  (∑ a ∈ H, (P 0 (fun k => Fin.elim0 k)).eval a = C) ∧
  (∀ i : Fin n, ∀ h : 0 < i.val,
    let i_prev : Fin n := ⟨i.val - 1, by
      have := i.is_lt
      omega⟩
    let r_prev_args : Fin i_prev → F := fun k => r ⟨k.val, by
      have h1 := k.is_lt
      have h2 := i_prev.is_lt
      omega⟩
    let r_last : F := r i_prev
    ∑ a ∈ H, (P i (fun k => r ⟨k.val, lt_trans k.is_lt i.is_lt⟩)).eval a =
      (P i_prev r_prev_args).eval r_last) ∧
  (let last_idx : Fin n := ⟨n - 1, Nat.pred_lt (NeZero.ne n)⟩
   let r_prev_args : Fin last_idx → F := fun k => r ⟨k.val, lt_trans k.is_lt last_idx.is_lt⟩
   (P last_idx r_prev_args).eval (r last_idx) = eval r g)

/-
The honest prover's polynomial in the final round, evaluated at the final challenge, equals the evaluation of the original multivariate polynomial at the full challenge vector.
-/
open MvPolynomial Finset Polynomial

theorem honest_prover_final_check {F : Type*} [Field F] [Fintype F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin n) F) (H : Finset F) (r : Fin n → F) :
    let last_idx : Fin n := ⟨n - 1, Nat.pred_lt (NeZero.ne n)⟩
    let r_prev : Fin last_idx → F := fun k => r ⟨k.val, lt_trans k.is_lt last_idx.is_lt⟩
    (honest_prover_poly g H last_idx r_prev).eval (r last_idx) = eval r g := by
  generalize_proofs at *;
  unfold honest_prover_poly;
  rcases n with rfl | _ <;> simp_all +decide [ Fin.eq_last_of_not_lt ];
  simp +decide [ Polynomial.eval_finset_sum, MvPolynomial.aeval_def ];
  simp +decide [ MvPolynomial.eval₂_eq' ];
  simp +decide [ Polynomial.eval_finset_sum, MvPolynomial.eval_eq' ];
  simp +decide [ Fin.prod_univ_castSucc, Polynomial.eval_prod ]

/-
If $C = \sigma(g, H, n)$ and the prover follows the honest strategy, then the verifier accepts.
-/
open MvPolynomial Finset Polynomial

/-- The honest prover strategy. -/
def HonestStrategy {F : Type*} [Field F] [Fintype F] {n : ℕ}
    (g : MvPolynomial (Fin n) F) (H : Finset F) : ProverStrategy n F :=
  fun i r => honest_prover_poly g H i r

theorem completeness {F : Type*} [Field F] [Fintype F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin n) F) (H : Finset F) (C : F) (d : ℕ)
    (hC : C = sigma g H) (hd : ∀ i, degreeOf i g ≤ d) :
    ∀ r : Fin n → F, VerifierAccepts g H C d (HonestStrategy g H) r := by
      intro r;
      constructor;
      · exact fun i => honest_prover_degree_le g H i _ ( hd i );
      · refine' ⟨ _, _, _ ⟩;
        · convert honest_prover_sum_check_zero g H ⟨ 0, NeZero.pos n ⟩ ( fun k => Fin.elim0 k ) rfl;
        · rcases n with ( _ | _ | n ) <;> norm_num at *;
          rintro ⟨ _ | i, hi ⟩ <;> norm_num at *;
          intro h;
          convert honest_prover_sum_check_succ g H ⟨ i, by linarith ⟩ _ using 1;
        · convert honest_prover_final_check g H r using 1

/-
The honest prover's polynomial for round 0, evaluated at r0, equals sigma of the partially evaluated polynomial.
-/
open MvPolynomial Finset Polynomial

theorem honest_prover_eval_zero_eq_sigma_eval {F : Type*} [Field F] [Fintype F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin (n + 1)) F) (H : Finset F) (r0 : F) :
    (honest_prover_poly g H 0 (Fin.elim0)).eval r0 =
    sigma (MvPolynomial.eval₂ MvPolynomial.C (Fin.cons (MvPolynomial.C r0) MvPolynomial.X) g) H := by
      unfold honest_prover_poly sigma; simp +decide [ Fin.forall_fin_one ] ;
      simp +decide [ Polynomial.eval_finset_sum, MvPolynomial.aeval_def, MvPolynomial.eval₂_eq' ];
      simp +decide [ Fin.prod_univ_succ, Polynomial.eval_prod ]

/-
The base case of the soundness proof (n=1). If the claimed sum is incorrect, the probability of acceptance is at most d/|F|.
-/
open MvPolynomial Finset Polynomial

theorem soundness_base_case {F : Type*} [Field F] [Fintype F] [DecidableEq F]
    (g : MvPolynomial (Fin 1) F) (H : Finset F) (C : F) (d : ℕ)
    (hC : C ≠ sigma g H) (hd : degreeOf 0 g ≤ d) :
    ∀ P : ProverStrategy 1 F,
    Prob (Fintype.piFinset fun _ : Fin 1 => univ) (VerifierAccepts g H C d P) ≤ (d : ℚ) / Fintype.card F := by
  intro P;
  -- Let $s_0^*(X) = g(X)$ be the honest prover's polynomial.
  set s0 : Polynomial F := MvPolynomial.eval₂ Polynomial.C (fun i => if i = 0 then Polynomial.X else 0) g;
  -- The prover's polynomial $s_0$ must satisfy $\deg(s_0) \le d$ and $\sum_{a \in H} s_0(a) = C$.
  have hP0 : ∀ r : Fin 1 → F, VerifierAccepts g H C d P r → (P 0 (fun _ => Fin.elim0 ‹_›)).degree ≤ d ∧ (∑ a ∈ H, (P 0 (fun _ => Fin.elim0 ‹_›)).eval a) = C ∧ (P 0 (fun _ => Fin.elim0 ‹_›)).eval (r 0) = s0.eval (r 0) := by
    intro r hr
    obtain ⟨h_deg, h_sum, h_eval⟩ := hr;
    simp_all +decide [ Fin.eq_zero ];
    refine' ⟨ _, _ ⟩;
    · convert h_deg using 1;
      convert rfl;
    · convert h_eval using 1;
      · convert rfl;
      · simp +zetaDelta at *;
        erw [ MvPolynomial.eval_eq', MvPolynomial.eval₂_eq' ];
        simp +decide [ Polynomial.eval_finset_sum ];
  -- Since $C \neq \sigma(g, H, 1)$, we have $\sum s_0(a) \neq \sum s_0^*(a)$, so $s_0 \neq s_0^*$.
  have hP0_ne_s0 : ∀ r : Fin 1 → F, VerifierAccepts g H C d P r → (P 0 (fun _ => Fin.elim0 ‹_›)) ≠ s0 := by
    intro r hr hP0_eq_s0
    have h_sum_eq : ∑ a ∈ H, (P 0 (fun _ => Fin.elim0 ‹_›)).eval a = ∑ a ∈ H, s0.eval a := by
      rw [ hP0_eq_s0 ]
    simp_all +decide [ sigma ];
    refine' hC _;
    rw [ ← hP0 r hr |>.2 ];
    refine' Finset.sum_bij ( fun x hx => fun _ => x ) _ _ _ _ <;> simp +decide;
    · simp +decide [ funext_iff, Fin.forall_fin_one ];
    · exact fun b hb => ⟨ b 0, hb, by ext i; fin_cases i; rfl ⟩;
    · simp +zetaDelta at *;
      intro a ha; erw [ MvPolynomial.eval_eq' ] ; simp +decide [ MvPolynomial.eval₂_eq' ] ;
      simp +decide [ Polynomial.eval_finset_sum ];
  -- By Schwartz-Zippel, $\Prob[s_0(r_0) = s_0^*(r_0)] \leq d / |F|$.
  have hP0_prob : ∀ r : Fin 1 → F, VerifierAccepts g H C d P r → (P 0 (fun _ => Fin.elim0 ‹_›)).eval (r 0) = s0.eval (r 0) → (Polynomial.roots ((P 0 (fun _ => Fin.elim0 ‹_›)) - s0)).toFinset.card ≤ d := by
    intro r hr h_eval
    have h_deg : (P 0 (fun _ => Fin.elim0 ‹_›) - s0).degree ≤ d := by
      refine' le_trans ( Polynomial.degree_sub_le _ _ ) ( max_le ( hP0 r hr |>.1 ) _ );
      refine' le_trans ( Polynomial.degree_sum_le _ _ ) _;
      simp +decide [ MvPolynomial.degreeOf_eq_sup ] at hd ⊢;
      intro b hb; specialize hd b hb; simp_all +decide [ Finsupp.prod ] ;
      rw [ Finset.prod_eq_single 0 ] <;> simp +decide [ hd ];
      aesop;
    exact le_trans ( Multiset.toFinset_card_le _ ) ( le_trans ( Polynomial.card_roots' _ ) ( Polynomial.natDegree_le_of_degree_le h_deg ) );
  -- Therefore, the probability that the verifier accepts is at most $d / |F|$.
  have hP0_accept_prob : (Finset.filter (fun r : Fin 1 → F => VerifierAccepts g H C d P r) (Fintype.piFinset fun _ => Finset.univ)).card ≤ d := by
    have hP0_accept_prob : (Finset.filter (fun r : Fin 1 → F => VerifierAccepts g H C d P r) (Fintype.piFinset fun _ => Finset.univ)).card ≤ (Polynomial.roots ((P 0 (fun _ => Fin.elim0 ‹_›)) - s0)).toFinset.card := by
      have hP0_accept_prob : Finset.image (fun r : Fin 1 → F => r 0) (Finset.filter (fun r : Fin 1 → F => VerifierAccepts g H C d P r) (Fintype.piFinset fun _ => Finset.univ)) ⊆ (Polynomial.roots ((P 0 (fun _ => Fin.elim0 ‹_›)) - s0)).toFinset := by
        simp +decide [ Finset.subset_iff ];
        exact fun r hr => ⟨ sub_ne_zero_of_ne ( hP0_ne_s0 r hr ), sub_eq_zero.mpr ( hP0 r hr |>.2.2 ) ⟩;
      exact le_trans ( by rw [ Finset.card_image_of_injective _ fun x y hxy => by ext i; fin_cases i; exact hxy ] ) ( Finset.card_mono hP0_accept_prob );
    by_cases h : ∃ r : Fin 1 → F, VerifierAccepts g H C d P r <;> simp_all +decide;
    exact le_trans hP0_accept_prob ( hP0_prob _ h.choose_spec );
  rw [ show Prob ( Fintype.piFinset fun _ => Finset.univ ) ( VerifierAccepts g H C d P ) = ( Finset.card ( Finset.filter ( fun r : Fin 1 → F => VerifierAccepts g H C d P r ) ( Fintype.piFinset fun _ => Finset.univ ) ) : ℚ ) / ( Fintype.card F ) from ?_ ];
  · gcongr;
  · unfold Prob; aesop;

/-
If two polynomials have different sums over H, they agree at a random point with probability at most d/|F|.
-/
open MvPolynomial Finset Polynomial

theorem soundness_round_one_bound {F : Type*} [Field F] [Fintype F] [DecidableEq F]
    (H : Finset F) (C : F) (d : ℕ) (s_1 : Polynomial F) (s_1_star : Polynomial F)
    (h_deg : s_1.degree ≤ d) (h_deg_star : s_1_star.degree ≤ d)
    (h_sum : ∑ a ∈ H, s_1.eval a = C)
    (h_sum_star : ∑ a ∈ H, s_1_star.eval a ≠ C) :
    Prob (Fintype.piFinset fun _ : Fin 1 => (Finset.univ : Finset F))
      (fun r => s_1.eval (r 0) = s_1_star.eval (r 0)) ≤ d / Fintype.card F := by
        have h_prob_bound : (Prob (Finset.univ : Finset F) (fun x => s_1.eval x = s_1_star.eval x)) ≤ d / (Fintype.card F) := by
          have h_diff : s_1 - s_1_star ≠ 0 := by
            exact sub_ne_zero_of_ne ( by aesop )
          have h_prob_bound : (Finset.card (Finset.filter (fun x => s_1.eval x = s_1_star.eval x) (Finset.univ : Finset F))) ≤ d := by
            have := Polynomial.card_roots' ( s_1 - s_1_star );
            exact le_trans ( Finset.card_le_card ( show Finset.filter ( fun x => Polynomial.eval x s_1 = Polynomial.eval x s_1_star ) Finset.univ ⊆ ( s_1 - s_1_star |> Polynomial.roots |> Multiset.toFinset ) from fun x hx => by aesop ) ) ( le_trans ( Multiset.toFinset_card_le _ ) ( this.trans ( Polynomial.natDegree_le_of_degree_le ( le_trans ( Polynomial.degree_sub_le _ _ ) ( max_le h_deg h_deg_star ) ) ) ) );
          exact div_le_div_of_nonneg_right ( mod_cast h_prob_bound ) ( Nat.cast_nonneg _ );
        convert h_prob_bound using 1;
        convert rfl;
        refine' congr_arg₂ _ ( mod_cast _ ) ( mod_cast _ );
        · refine' Finset.card_bij ( fun x hx => fun _ => x ) _ _ _ <;> simp +decide;
          · simp +decide [ funext_iff, Fin.forall_fin_one ];
          · exact fun b hb => ⟨ b 0, hb, by ext i; fin_cases i; rfl ⟩;
        · simp +decide [ Fintype.card_pi ]

/-
Individual degree bounds are preserved when partially evaluating the first variable.
-/
open MvPolynomial Finset Polynomial

theorem degreeOf_eval2_cons_le {F : Type*} [Field F] {n : ℕ}
    (g : MvPolynomial (Fin (n + 1)) F) (r0 : F) (d : ℕ)
    (hd : ∀ i, degreeOf i g ≤ d) :
    ∀ i : Fin n, degreeOf i (MvPolynomial.eval₂ MvPolynomial.C (Fin.cons (MvPolynomial.C r0) MvPolynomial.X) g) ≤ d := by
      intro i
      have := hd (Fin.succ i);
      rw [ MvPolynomial.eval₂_eq' ] at *;
      simp +decide [ MvPolynomial.degreeOf_eq_sup, Fin.prod_univ_succ ] at this ⊢;
      simp +decide [ MvPolynomial.coeff_sum, MvPolynomial.coeff_C_mul, MvPolynomial.coeff_X_pow ];
      intro b hb;
      obtain ⟨ x, hx ⟩ := Finset.exists_ne_zero_of_sum_ne_zero hb;
      rw [ show ( MvPolynomial.C r0 ^ ( x 0 ) * ∏ i : Fin n, MvPolynomial.X i ^ ( x ( Fin.succ i ) ) ) = MvPolynomial.monomial ( ∑ i : Fin n, x ( Fin.succ i ) • Finsupp.single i 1 ) ( r0 ^ ( x 0 ) ) from ?_ ] at hx;
      · simp_all +decide [ MvPolynomial.coeff_monomial ];
        rw [ ← hx.2.1 ] ; simp +decide [ Finsupp.single_apply, Finset.sum_apply' ] ; aesop;
      · simp +decide [ MvPolynomial.monomial_eq, Finset.prod_pow_eq_pow_sum ];
        simp +decide [ Finsupp.single_apply, Finset.sum_apply' ]

/-
Verifier acceptance decomposes into the first round checks and the acceptance of the recursive instance.
-/
open MvPolynomial Finset Polynomial

/-- The strategy for the recursive instance, given the first challenge r0. -/
def tailStrategy {F : Type*} [Field F] {n : ℕ}
    (P : ProverStrategy (n + 1) F) (r0 : F) : ProverStrategy n F :=
  fun i r_prev => P i.succ (Fin.cons r0 r_prev)

theorem verifierAcceptsCons {F : Type*} [Field F] [Fintype F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin (n + 1)) F) (H : Finset F) (C : F) (d : ℕ)
    (P : ProverStrategy (n + 1) F) (r0 : F) (r_tail : Fin n → F) :
    VerifierAccepts g H C d P (Fin.cons r0 r_tail) ↔
    (P 0 (fun _ => Fin.elim0 ‹_›)).degree ≤ d ∧
    (∑ a ∈ H, (P 0 (fun _ => Fin.elim0 ‹_›)).eval a = C) ∧
    VerifierAccepts (MvPolynomial.eval₂ MvPolynomial.C (Fin.cons (MvPolynomial.C r0) MvPolynomial.X) g) H ((P 0 (fun _ => Fin.elim0 ‹_›)).eval r0) d (tailStrategy P r0) r_tail := by
  constructor;
  · rintro ⟨ hP, hC, hP', h_eval ⟩;
    refine' ⟨ _, hC, _ ⟩;
    · convert hP 0 using 1;
      exact congr_arg Polynomial.degree ( by congr; ext x; fin_cases x );
    · refine' ⟨ _, _, _, _ ⟩;
      · intro i;
        convert hP ( Fin.succ i ) using 1;
        unfold tailStrategy;
        congr! 2;
        exact funext fun x => by cases x using Fin.inductionOn <;> rfl;
      · simp_all +decide [ Fin.forall_fin_succ ];
        convert hP' ⟨ 0, NeZero.pos n ⟩ using 1;
        · simp +decide [ tailStrategy ];
          exact Finset.sum_congr rfl fun _ _ => by congr; ext i; fin_cases i; rfl;
        · congr! 1;
          exact congr_arg _ ( funext fun k => by fin_cases k );
      · intro i hi;
        convert hP' ( Fin.succ i ) ( Nat.succ_pos _ ) using 1;
        simp +decide [ Fin.forall_fin_succ, tailStrategy ];
        congr! 2;
        · congr! 2;
          exact funext fun x => by cases x using Fin.inductionOn <;> rfl;
        · rcases i with ⟨ _ | i, hi ⟩ <;> tauto;
        · congr! 2;
          · exact Nat.succ_pred_eq_of_pos hi;
          · rw [ Nat.sub_add_cancel hi ];
          · rename_i k hk;
            rcases i with ⟨ _ | i, hi ⟩ <;> simp_all +decide [ Fin.cons ];
            induction k using Fin.inductionOn <;> aesop;
      · field_simp;
        convert h_eval using 1;
        · unfold tailStrategy;
          congr! 2;
          · rcases n with ( _ | n ) <;> simp +decide [ Fin.cons ] at *;
            exact False.elim ( NeZero.ne 0 rfl );
          · exact Fin.ext ( Nat.succ_pred_eq_of_pos ( NeZero.pos n ) );
          · rcases n with ( _ | n ) <;> simp_all +decide [ Fin.cons ];
            · exact False.elim ( NeZero.ne 0 rfl );
            · exact funext fun i => by cases i using Fin.inductionOn <;> rfl;
        · erw [ MvPolynomial.eval_eval₂ ];
          congr;
          · exact RingHom.ext fun x => by simp +decide ;
          · ext i; induction i using Fin.inductionOn <;> simp +decide [ * ] ;
  · intro h;
    unfold VerifierAccepts at *;
    refine' ⟨ _, _, _, _ ⟩ <;> simp_all +decide [ Fin.forall_fin_succ ];
    · refine' ⟨ _, _ ⟩
      all_goals generalize_proofs at *;
      · convert h.1 using 1;
        exact congr_arg _ ( by congr; ext i; fin_cases i );
      · intro i; specialize h; have := h.2.2.1 i; simp_all +decide [ Fin.forall_fin_succ, tailStrategy ] ;
        convert h.2.2.1 i using 1;
        congr! 2;
        ext ⟨ k, hk ⟩ ; induction k <;> aesop;
    · intro i; specialize h; rcases i with ⟨ _ | i, hi ⟩ <;> simp_all +decide [ Fin.forall_fin_succ ] ;
      · convert h.2.2.2.1 using 1
        generalize_proofs at *;
        · congr! 2;
          exact congr_arg _ ( funext fun k => by fin_cases k; rfl );
        · convert rfl;
      · convert h.2.2.2.2.1 ⟨ i + 1, hi ⟩ ( Nat.succ_pos _ ) using 1;
        · congr! 2;
          exact congr_arg _ ( funext fun k => by cases k using Fin.inductionOn <;> rfl );
        · simp +decide [ Fin.cons, tailStrategy ];
          congr! 2;
          exact funext fun k => by cases k using Fin.inductionOn <;> rfl;
    · convert h.2.2.2.2.2 using 1;
      · rcases n <;> simp_all +decide [ Fin.cons ];
        · exact False.elim ( NeZero.ne 0 rfl );
        · convert h.2.2.2.2.2 using 1
          generalize_proofs at *;
          unfold tailStrategy; simp +decide [ Fin.cases ] ;
          congr! 2
          generalize_proofs at *;
          ext i; induction i using Fin.inductionOn <;> simp +decide [ * ] ;
          rfl;
      · erw [ MvPolynomial.eval_eq', MvPolynomial.eval₂_eq' ];
        simp +decide [ Fin.prod_univ_succ, MvPolynomial.eval_C, MvPolynomial.eval_X ]

/-
The inductive step of the soundness proof: if soundness holds for n variables, it holds for n+1.
-/
open MvPolynomial Finset Polynomial

theorem soundness_step {F : Type*} [Field F] [Fintype F] [DecidableEq F] {n : ℕ} [NeZero n]
    (IH : ∀ (g' : MvPolynomial (Fin n) F) (H : Finset F) (C' : F) (d : ℕ),
      C' ≠ sigma g' H → (∀ i, degreeOf i g' ≤ d) →
      ∀ P' : ProverStrategy n F,
      Prob (Fintype.piFinset fun _ : Fin n => univ) (VerifierAccepts g' H C' d P') ≤ (n * d : ℚ) / Fintype.card F)
    (g : MvPolynomial (Fin (n + 1)) F) (H : Finset F) (C : F) (d : ℕ)
    (hC : C ≠ sigma g H) (hd : ∀ i, degreeOf i g ≤ d) :
    ∀ P : ProverStrategy (n + 1) F,
    Prob (Fintype.piFinset fun _ : Fin (n + 1) => univ) (VerifierAccepts g H C d P) ≤ ((n + 1) * d : ℚ) / Fintype.card F := by
      field_simp;
      intro P
      have h_sum : (∑ r0 : F, Prob (Fintype.piFinset (fun _ : Fin n => Finset.univ)) (fun r_tail => VerifierAccepts g H C d P (Fin.cons r0 r_tail)) : ℚ) ≤ (n + 1) * d := by
        by_cases h_deg : ∀ r0 : F, (P 0 (fun _ => Fin.elim0 ‹_›)).degree ≤ d ∧ (∑ a ∈ H, (P 0 (fun _ => Fin.elim0 ‹_›)).eval a = C);
        · have h_sum : (∑ r0 : F, if (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0 then 1 else (n * d : ℚ) / Fintype.card F) ≤ (n + 1) * d := by
            have h_sum : (∑ r0 : F, if (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0 then 1 else 0 : ℚ) ≤ d := by
              have h_sum : (Finset.univ.filter (fun r0 : F => (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0)).card ≤ d := by
                have h_card_B : (Finset.filter (fun r0 => (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0) Finset.univ).card ≤ (Polynomial.roots ((P 0 (fun _ => Fin.elim0 ‹_›)) - (honest_prover_poly g H 0 (Fin.elim0)))).toFinset.card := by
                  refine Finset.card_le_card ?_;
                  intro r hr; simp_all +decide [ sub_eq_iff_eq_add ] ;
                  intro h; simp_all +decide [ Finset.sum_const_zero ] ;
                  exact hC ( h_deg.2.symm ▸ by simp +decide [ honest_prover_sum_check_zero ] );
                refine' le_trans h_card_B ( le_trans ( Multiset.toFinset_card_le _ ) ( le_trans ( Polynomial.card_roots' _ ) _ ) );
                refine' le_trans ( Polynomial.natDegree_sub_le _ _ ) _;
                refine' max_le _ _;
                · exact Polynomial.natDegree_le_of_degree_le ( h_deg 0 |>.1 );
                · refine' le_trans ( Polynomial.natDegree_le_of_degree_le _ ) _;
                  exact d;
                  · convert honest_prover_degree_le g H 0 Fin.elim0 ( hd 0 ) using 1;
                  · norm_num;
              aesop;
            have h_sum : (∑ r0 : F, if (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0 then 1 else (n * d : ℚ) / Fintype.card F) ≤ (∑ r0 : F, if (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0 then 1 else 0 : ℚ) + (n * d : ℚ) := by
              simp +decide [ Finset.sum_ite ];
              rw [ mul_div, div_le_iff₀ ] <;> norm_cast;
              · rw [ mul_comm ] ; gcongr ; exact Finset.card_le_univ _;
              · exact Fintype.card_pos_iff.mpr ⟨ 0 ⟩;
            linarith;
          refine' le_trans ( Finset.sum_le_sum _ ) h_sum;
          intro r0 hr0
          by_cases h_eq : (P 0 (fun _ => Fin.elim0 ‹_›)).eval r0 = (honest_prover_poly g H 0 (Fin.elim0)).eval r0;
          · rw [ if_pos h_eq ];
            exact div_le_one_of_le₀ ( mod_cast le_trans ( Finset.card_filter_le _ _ ) ( by simp +decide ) ) ( Nat.cast_nonneg _ );
          · convert IH ( MvPolynomial.eval₂ MvPolynomial.C ( Fin.cons ( MvPolynomial.C r0 ) MvPolynomial.X ) g ) H ( ( P 0 fun _ => Fin.elim0 ‹_› ).eval r0 ) d _ _ ( tailStrategy P r0 ) using 1;
            · congr! 2;
              rw [ verifierAcceptsCons ];
              exact ⟨ fun h => h.2.2, fun h => ⟨ h_deg r0 |>.1, h_deg r0 |>.2, h ⟩ ⟩;
            · rw [ if_neg h_eq ];
            · convert h_eq using 1;
              exact (honest_prover_eval_zero_eq_sigma_eval g H r0).symm;
            · exact degreeOf_eval2_cons_le g r0 d hd;
        · refine' le_trans ( Finset.sum_le_sum fun r0 _ => _ ) _;
          use fun r0 => if ( P 0 fun _ => Fin.elim0 ‹_› ).degree ≤ d ∧ ∑ a ∈ H, Polynomial.eval a ( P 0 fun _ => Fin.elim0 ‹_› ) = C then 1 else 0;
          · split_ifs <;> simp_all +decide [ VerifierAccepts ];
            simp +decide [ Prob ];
            field_simp;
            simp +decide [ Fin.forall_fin_succ ];
            grind;
          · by_cases h : ( P 0 fun _ => Fin.elim0 ‹_› ).degree ≤ d ∧ ∑ a ∈ H, Polynomial.eval a ( P 0 fun _ => Fin.elim0 ‹_› ) = C <;> simp_all +decide;
            split_ifs <;> norm_cast ; aesop;
            positivity;
      convert h_sum using 1;
      rw [ prob_split ];
      simp +decide [ Finset.card_univ ]

/-
Soundness: If $C \neq \sigma(g, H, n)$ and $g$ has individual degree at most $d$ in each variable,
then for any prover strategy $P$:
$\Prob_{r_1, \ldots, r_n \sim \FF}[\text{verifier accepts}] \leq n \cdot d / |\FF|$.
The proof proceeds by induction on $n$, combining soundness_base_case and soundness_step.
-/
open MvPolynomial Finset Polynomial

theorem soundness {F : Type*} [Field F] [Fintype F] [DecidableEq F] {n : ℕ} [NeZero n]
    (g : MvPolynomial (Fin n) F) (H : Finset F) (C : F) (d : ℕ)
    (hC : C ≠ sigma g H) (hd : ∀ i, degreeOf i g ≤ d) :
    ∀ P : ProverStrategy n F,
    Prob (Fintype.piFinset fun _ : Fin n => univ) (VerifierAccepts g H C d P) ≤ (n * d : ℚ) / Fintype.card F := by
  sorry
